# GoF 的 23 种设计模式的分类和功能

## 根据目的来分
* 创建型模式：
* 结构型模式：
* 行为性模式：

## 根据作用范围来分
* 类模式：
* 对象模式：

## 详情如下表

|范围\目的|创建型模式|结构型模式|行为型模式|
|:-------|:-------|:--------|:--------|
|类模式|工厂方法|(类）适配器|模板方法<br/>解释器|
|对象模式|单例<br/>原型<br/>抽象工厂<br/>建造者|代理<br/>(对象）适配器<br/>桥接<br/>装饰<br/>外观<br/>享元<br/>组合|策略<br/>命令<br/>职责链<br/>状态<br/>观察者<br/>中介者<br/>迭代器<br/>访问者<br/>备忘录|

## 23种设计模式的功能

* 01 **Singleton**: 只生成一个实例
* 02 **Prototype**(原型): 将一个对象作为原型，通过对其clone出多个新实例。
* 03 **Factory Method**: 步骤相同，创建的对象不同，选择使用工厂方法。
* 04 AbstractFactory: 
* 05 **Builder**: 讲一个复杂对象分解多个简单对象，最后组合
* 06 **Proxy**: 对原有方法做增强操作
* 07 Adapter:
* 08 Bridge:
* 09 **Decorator**: 动态给对象增加一些功能。
* 10 **Facade**: 对复杂子系统提供一个一直的接口，供外部访问
* 11 Flyweight:
* 12 Composite:
* 13 TemplateMethod:
* 14 **Strategy**: 定义一些列算法，使他们可以互相替换。
* 15 **Command**: 一个请求分装为一个对象，将 责任和请求 分隔开。
* 16 **Chain of Responsibility**: 一个传一个，直到最后。
* 17 State:
* 18 **Observer**: 一个对象发生变化时，通知其他对象，对此变化做相应的行为。
* 19 **Mediator**:降低对象间的耦合，使得对象之间不必互相了解
* 20 Iterator:
* 21 **Visitor**:不改变集合元素的前提下，使每个元素有多个访问者访问。
* 22 Memento:
* 23 Interpreter:

## 软件设计中的7大原则
### 1 开闭原则: 软件设计应当对扩展开放，对修改关闭
### 2 里氏替换原则: 继承必须拥有super类的属性
* 2.1 子类可以实现父类的抽象方法，单不能覆盖父类的非抽象方法。
* 2.2 子类可以增加自己的特性
* 2.3 当子类重载父类的方法时，前置条件(入参)要比父类更宽松
* 2.4 当子类实现父类的方法时，后置条件(出参)要比父类方法更严格
### 3 依赖倒置原则: 通过要面向接口的变成来降低类间的耦合性。
* 3.1 每个类尽量提供接口或抽象类，或者两者都具备。
* 3.2 变量的声明类型尽量是接口或者是抽象类。
* 3.3 任何类都不应该从具体类派生。
* 3.4 使用继承时尽量遵循里氏替换原则。
### 4 单一职责原则: 规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分
### 5 接口隔离原则: 要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。
* 5.1 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
* 5.2 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。
* 5.3 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。
* 5.4 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。
### 6 迪米特法则: 只与你的直接朋友交谈，不跟“陌生人”说话
* 6.1 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
* 6.2 在类的结构设计上，尽量降低类成员的访问权限。
* 6.3 在类的设计上，优先考虑将一个类设置成不变类。
* 6.4 在对其他类的引用上，将引用其他对象的次数降到最低。
* 6.5 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。
* 6.6 谨慎使用序列化（Serializable）功能。
### 7 合成复用原则:它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。
* 7.1 通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。


