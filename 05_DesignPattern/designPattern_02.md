# GoF 的 23 种设计模式的分类和功能

## 根据目的来分
* 创建型模式：
* 结构型模式：
* 行为性模式：

## 根据作用范围来分
* 类模式：
* 对象模式：

## 详情如下表

|范围\目的|创建型模式|结构型模式|行为型模式|
|:-------|:-------|:--------|:--------|
|类模式|工厂方法|(类）适配器|模板方法<br/>解释器|
|对象模式|单例<br/>原型<br/>抽象工厂<br/>建造者|代理<br/>(对象）适配器<br/>桥接<br/>装饰<br/>外观<br/>享元<br/>组合|策略<br/>命令<br/>职责链<br/>状态<br/>观察者<br/>中介者<br/>迭代器<br/>访问者<br/>备忘录|

## 23种设计模式的功能

* 01 **Singleton**: 只生成一个实例
* 02 **Prototype**(原型): 将一个对象作为原型，通过对其clone出多个新实例。
* 03 **Factory Method**: 步骤相同，创建的对象不同，选择使用工厂方法。
* 04 AbstractFactory: 
* 05 **Builder**: 讲一个复杂对象分解多个简单对象，最后组合
* 06 **Proxy**: 对原有方法做增强操作
* 07 Adapter:
* 08 Bridge:
* 09 **Decorator**: 动态给对象增加一些功能。
* 10 **Facade**: 对复杂子系统提供一个一直的接口，供外部访问
* 11 Flyweight:
* 12 Composite:
* 13 TemplateMethod:
* 14 **Strategy**: 定义一些列算法，使他们可以互相替换。
* 15 **Command**: 一个请求分装为一个对象，将 责任和请求 分隔开。
* 16 **Chain of Responsibility**: 一个传一个，直到最后。
* 17 State:
* 18 **Observer**: 一个对象发生变化时，通知其他对象，对此变化做相应的行为。
* 19 **Mediator**:降低对象间的耦合，使得对象之间不必互相了解
* 20 Iterator:
* 21 **Visitor**:不改变集合元素的前提下，使每个元素有多个访问者访问。
* 22 Memento:
* 23 Interpreter:

