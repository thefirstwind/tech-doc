# Mysql讲解

<!--https://www.bilibili.com/video/BV1bD4y1m7RU?from=search&seid=2211861062542380942-->

## 1 Mysql的相关知识点需要了解哪些
* 调优
* 索引
* MVCC
* 存储索引
* 事务
* 主从复制
* 读写分离
* 分库分表
* 锁
* 日志系统

## 2 Mysql的整体架构
* 连接器：管理连接，验证权限
* 分析器：词法分析，语法分析
  * sharding-sphere: 数据库中间件，重点关注
* 优化器：一共134个优化器自动选择
  * CBO：基于 成本 的优化
  * RBO：基于 规则 的优化
```
select * from A join B join C
并不是，先查A再查B再查C
```
![](images/2F4733C7-00F5-4417-9F45-15F56F1040F6.png)

如图 顺序不是严格按照 ABC的顺序执行的

如果一定要按照ABC的顺序的话，使用 straight_join 方法，一般来说不建议使用

* 执行器：用来跟存储引擎直接做交互
* 存储引擎：innodb，myisam，memory
  * innodb支持事务，myisam不支持
  * innodb支持外检，myisam不支持
  * innodb支持表锁和行锁，但是myisam只支持标锁
  * innodb在5.6之后 支持全文索引，myisam一直支持
  * innodb是索引的叶子节点，直接存放数据，myisam存的是地址

mysql的架构图
![](images/A763A8FE-6D1C-4668-83C6-8D707706D388.png)

* sql解析的工具：calcite、antlr
> sql解析工具

* 索引能加快数据，索引要不要保存到磁盘？ 要的
  * 局部性原理：数据和程序都有聚集成群的倾向，空间局部性，时间局部性
  * 磁盘预读：按照块区来读取。这个逻辑单位叫做页，datapage，一般是4K或者8K，在读取的时候都是4K的整数呗，innodb每次读取16K的数据

* mysql索引的数据结构
  * hash：memory索引存储使用hash索引，innodb支持自适应hash
  * 树：B+树
    * 多叉树
    * 节点有序
    * 每一个节点可以存储多个数据
    * 是一颗平衡树

## 3 B+树的介绍
### 3.1 B+树在B树的基础上做了以下的优化
![](images/51D1F684-91FC-4E95-9B89-0AD42B959206.png);

### 3.1 B+树的层级
B+树 里面一个节点所能保证的是 degree-1条记录mysql的索引，一般有几层？

一般情况下，3、4层足以支撑千万级表的查询

### 3.2 创建索引的字段 是长了好还是短了好？
短了好。 原因在层数不变的时候，可以存出更多的数据量

* 我们在创建表的时候是在代理主键还是自然主键
* 

## 4 B树
计算机有一个局部性原理，就是说，当一个数据被用到时，其附近的数据也通常会马上被使用
使用红黑树的话，一次只能得到一个健值的信息，而用B树的话，可以得到最多M-1个健值信息。
红黑树阶数更大，B树更短，这样查找的时候B树就更有优势，效率更高。

### 4.1 B树的概念
* 首先B树是二叉查找树的改进
* B树的设计思想：将相关数据尽量集中在一起，以便一次读取多个数据
* 根节点至少有2个子节点
* 每个节点有M-1个KEY，而且升序排列
* 位于M-1和 M key的子节点的值位于M-1和M key对应的value之间
* 其他节点至少有M/2个子节点
* 所有叶子节点都在同一层
![](images/1BDFEE5A-D560-4A2F-BFB4-BDBD340D9BA0.png)
### 4.3 B树的插入
![](images/A763A8FE-6D1C-4668-83C6-8D707706D389.png)
* 把已满的中间值上拉，然后中间健值右边的所有健值和所有孩子都放到新节点中，挂成新节点的孩子

## 5 B+树
<!--https://zhuanlan.zhihu.com/p/149287061-->
### 5.1 B+树的概念
* 定义和B树基本相同，除了：
* 非叶子节点的子树指针与 关键字 个数相同
* 非叶子节点的子树指针P[i],指向关键字值属于(K[i],K[i+1])的子树
* 为所有叶子节点增加一个链指针
* 所有关键字都在叶子节点上出现
![](images/FD7B6B11-80A9-40FF-93FE-4D5B5F176D5B.png)

### 5.2  B+树的特点：
> B+树通过仅在树的叶子结点中存储数据指针而消除了上述缺陷。  
> 因此，B+树的叶结点的结构与 B树的内部结点的结构完全不同。  
> 在这里应该注意，由于数据指针仅存在于叶子结点中，因此叶子结点必须将所有键值及其对应的数据指针存储到磁盘文件块以便访问。  
> 此外，叶子结点被链接磁盘的某个位置，以提供对记录的有序访问。  
> 因此，叶子结点形成第一级索引，而内部结点形成多层索引的其他层。  
> 叶子结点的某些关键字 key 也出现在内部结点中，充当控制搜索记录的媒介。

### 5.2 B+树的查找
![](images/7129440A-671C-4611-BA47-4F8569FEDC3D.png)
* B+树中所有数据均保存在叶子节点上

* 第一次磁盘 I/O ：访问根结点 [59、97] ，发现 59 小于等于 [59、97] 中的 59 ，则访问根结点的第一个孩子结点。
![](images/2F3B4C0C-6D48-4769-B162-A62E5CC22878.png)
* 第二次磁盘 I/O : 访问结点 [15、44、59] ，发现 59 大于 44 且小于等于 59 ，则访问当前结点的第三个孩子结点 [51、59]
![](images/D2BF1EE9-C196-4578-BA02-4442910EA468.png)
* 第三次磁盘 I/O ：访问叶子结点 [51、59] ，顺序遍历结点内部，找到要查找的元素 59
![](images/87A304AF-6273-418E-98CC-D4021A24B5DB.png)

### 5.3 比较 B树和B+树的查找过程
查询[21,63]之间的数据

#### 5.3.1 B树的查询过程

* B树的数据结构
![](images/36CF5EB9-84B9-4244-B5E7-6B7714509544.png)

* 第一步：访问 B-树的根结点 [59] ，发现 21 比 59 小，则访问根结点的第一个孩子 [15、44]
![](images/AC194514-EB1F-41BB-8A90-8AB0ADDC2A68.png)

* 第二步：访问结点 [15、44] ，发现 21 大于 15 且小于 44 ，则访问当前结点的第二个孩子结点 [21、37]
![](images/C751AB13-2A72-483A-A405-A46D8601DF8B.png)

* 第三步：访问结点 [21、37] , 找到区间的左端点 21 ，然后从该关键字 21 开始，进行中序遍历，依次为关键字 37 、44、51、59，直到遍历到区间的右端点 63 为止， 不考虑中序遍历过程的压栈和入栈操作，光磁盘 I/O 次数就多了 2次，即访问结点 72 和结点 63
* 注意这里要进行多次中序遍历，而B+树是不需要的
![](images/CBE2BFD6-F98D-4032-BAEE-963F9A5EB76C.png)

#### 5.3.2 B+树的查询过程

* B+树的数据结构
![](images/07C8D86B-DCAC-4890-84E0-A3AA21045F5C.png)

* 第一步：访问根结点 [59、97] , 发现区间的左端点 21 小于 59， 则访问第一个左孩子 [15、44、59]
![](images/AA7C268D-A8DA-4E95-A47D-5D816F526F58.png)

* 第二步：访问结点 [15、44、59] ，发现 21 大于 15 且小于 44 ，则访问第二个孩子结点 [21、37，44]
![](images/A0A4731E-2769-4B31-BEAD-D9C000030203.png)

* 第三步：访问结点 [21、37，44] ，找到了左端点 21 ，此时 B+树的优越性就出来了，不再需要中序遍历，而是相当于单链表的遍历，直接从左端点 21 开始一直遍历到左端点 63 即可，没有任何额外的磁盘 I/O 操作
![](images/2BA9E8F0-4A39-46C3-9994-9BD831F43926.png)

### 5.4 B+树的插入操作
在B+树中插入关键字时，需要注意以下几点：

* 插入的操作全部都在叶子结点上进行，且不能破坏关键字自小而大的顺序；
* 由于 B+树中各结点中存储的关键字的个数有明确的范围，做插入操作可能会出现结点中关键字个数超过阶数的情况，此时需要将该结点进行 “分裂”；

![](images/FD7B6B11-80A9-40FF-93FE-4D5B5F176D51.gif)
![](images/FD7B6B11-80A9-40FF-93FE-4D5B5F176D52.gif)
![](images/FD7B6B11-80A9-40FF-93FE-4D5B5F176D53.gif)
![](images/FD7B6B11-80A9-40FF-93FE-4D5B5F176D54.gif)


![](images/FD7B6B11-80A9-40FF-93FE-4D5B5F176D55.gif)
![](images/FD7B6B11-80A9-40FF-93FE-4D5B5F176D56.gif)
![](images/FD7B6B11-80A9-40FF-93FE-4D5B5F176D57.gif)
### 4.5 B*树的概念
### 4.6 B树和B+树相关应用
https://www.bilibili.com/video/BV1bD4y1m7RU?p=5


